学习笔记
# 1. recursive
* 斐波那契数列的马甲
    * 兔子生小兔子问题
    * 爬楼梯问题
* 斐波那契数列的实现方式
    * recursive: O($2^n$)
    * iterable: O(n)
    * 通项公式：$((1-sqrt(5)/2)^n+(1+sqrt(5)/2)^n)$/$sqrt(5)/2$, O(log(n))
    * 矩阵运算：$[[1,1],[1,0]]^(n-1)$
# 2. 回溯：
* 思想就是在下一步出错时回退到上一步重新进行组合
* 子集，排列，组合都是用这种方式解决问题
* 回溯用到递归算法
* 回溯的套路：
    * 结束条件
    * 选择
    * 回溯
    * 回退
* 回溯的时间复杂度和空间复杂度并不小。实际上是一种暴力穷尽组合的方式，通过剪枝的方式，可以减少些时间复杂度。
* 剪枝就是提前判断不符合条件的组合，去除。

# 3. 分治
* 将问题拆分成子问题，利用递归解决，然后把结果组合起来
* 乘方运算，斐波那契数列

# 4.实战问题
4.1 子集：
* 库函数的应用itertool.combination()
* 迭代，内置函数的使用，labmda函数
* 递归，回溯

4.2 pow(x,n):
* 分治，递归

4.3 combination&&permute： 回溯，内置函数的使用（itertools.combination)

-------
# 5. 排序算法汇总：
## 5.1 冒泡排序
* 两两相比，把小的浮上来
* 需要双重循环，第一重循环记录次数（1，len(nums))，第二重两两比较（0，len(nums)-1）
* arr[j]>arr[j+1],两两交换
## 5.2 selectionSort
* 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
重复第二步，直到所有元素均排序完毕。
* 双重循环，第一重（0，len(nums)-1),第二重（i+1,len(nums)),
* arr[i]>arr[j],交换
## 5.3 insertionSort
* 实际上两个指针，一个指针记录数组元素，另外一个指针记录数元素前的序列。
## 5.4 希尔排序：
* 插入排序的优化，递减增量排序算法
* 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序（有分治的概念）
* 算法步骤：
    * 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
    * 按增量序列个数 k，对序列进行 k 趟排序；
    * 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
* 在leetcode上跑，时间超限了，比选择排序慢么？
## 5.5 归并排序：
* 选择排序的优化，采用了divide and conquer的思想
* 两种实现方法： 自上而下的递归，自下而上的迭代
* O(nlogn)，但是需要额外的空间
* 算法步骤：
    * 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
    * 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
    * 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
    * 重复步骤 3 直到某一指针达到序列尾；
    * 将另一序列剩下的所有元素直接复制到合并序列尾。
## 5.6 快速排序：
* 冒泡基础上的递归分治
* 算法步骤
    * 从数列中挑出一个元素，称为 “基准”（pivot）；
    * 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
    * 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
## 5.7 堆排序
* 利用堆概念进行的选择排序
## 5.8 计数排序
* 时间复杂度：O(n+k)，空间复杂度O(n)

## 5.9 桶排序
* 计数排序的升级版
* 为了使桶排序更加高效，我们需要做到这两点：
    * 在额外空间充足的情况下，尽量增大桶的数量
    * 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中
* 桶中数据的排序会影响桶排序的时间

## 5.10 基数排序
* 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。
* 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
* 
## 5.11 排序小结：
* 冒泡，选择，插入排序都是O(n^2)
* 归并排序，希尔排序，快速排序，堆排序都是O(nlog(n))
* 计数，桶是O(n+k)
* 基数排序是O(n*k)
* 基数排序 vs 计数排序 vs 桶排序
    * 基数排序：根据键值的每位数字来分配桶；
    * 计数排序：每个桶只存储单一键值；
    * 桶排序：每个桶存储一定范围的数值；
-------
# 6 总结：
* 本周学习了递归，分治和回溯
* 递归和回溯主要用在排列与组合上，暴力穷举的方式列举所有的可能
* 通过剪枝的方式提高效率
* 递归和回溯的差别是递归不需要进行回退的操作，但是回溯需要
* 递归思想套路：
    1. terminator
    2. 本层逻辑实现
    3. 递归
* 回溯思想套路：
    1. terminator
    2. 选择
    3. 回溯（递归）
    4. 回退
* 分治是一个很好的思想，分布式操作就是这个思想的实践

